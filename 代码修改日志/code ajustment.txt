你的需求是实现**主路与匝道车辆的协同控制**，并且有如下核心约束和目标：

- 主路车辆最低速度60 km/h（约16.67 m/s），匝道车辆最低速度20 km/h（约5.56 m/s）。
- 主路和匝道车辆都根据安全时距调控速度，进入汇入区时安全时距加大为1.5秒。
- 协调控制时，优先尝试让匝道车插入主路最近的主路车前方，若不可行则尝试插入第二、第三辆主路车前方。
- 所有车辆速度不得低于最低速度。
- 若协调成功，发布速度调节命令给相关车辆，其余主路车辆仍按安全时距跟驰。

---

## 详细修改思路

### 1. **最低速度约束**
- 在速度规划和控制（如 `Planner.plan_trajectory`、`Executor.apply_control`）中，分别对主路和匝道车辆设置不同的最低速度下限。
- 例如：主路车辆 `min_speed = 16.67`，匝道车辆 `min_speed = 5.56`，所有速度规划和控制都需 `max(规划速度, min_speed)`。

### 2. **安全时距动态调整**
- 在 `Planner.calculate_safe_distance` 中，判断车辆是否在汇入区（如 `vehicle.position[0] >= merging_zone[0]`），若是则 `time_gap=2.5`，否则用默认值。
- 该逻辑可通过传递参数或在 `plan_trajectory` 内部判断实现。

### 3. **主路与匝道车辆排序与识别**
- 在 controller.py 的 `update` 方法中，主路车辆按距离汇入点从近到远排序，匝道车辆同理。
- 记录主路上距离汇入点最近、第二近、第三近的车辆。

### 4. **协调控制核心逻辑**
- 对于每一帧，依次尝试让匝道车插入主路最近、第二近、第三近车辆前方：
    1. 计算主路车辆与匝道车辆的当前状态（位置、速度）。
    2. 预测两车到达汇入点的时间，判断是否能通过调节速度让匝道车在主路车前方安全汇入（即两车到达汇入点的时间差满足安全时距，且两车速度均不低于最低速度）。
    3. 若可行，规划两车的目标速度，并下发控制命令。
    4. 若不可行，尝试下一个主路车辆，直到第三辆。
- 其余主路车辆继续按安全时距跟驰。

### 5. **速度规划与下发**
- 若协调成功，将目标速度写入 `planned_speeds`，并通过 `Executor.apply_control` 下发。
- 其余车辆按常规安全时距跟驰，速度不低于最低速度。

### 6. **代码结构建议**
- 在 `Planner` 中增加一个 `coordinate_merge` 方法，专门实现上述协调控制逻辑，返回需要被协调的车辆的目标速度。
- 在 `plan_trajectory` 中优先调用 `coordinate_merge`，对被协调车辆单独处理，其余车辆按常规处理。
- 在 `Executor` 中确保所有车辆速度不低于最低速度。

---

## 伪代码流程

1. **车辆排序**
    - 主路车辆按距离汇入点升序排序，匝道车辆同理。

2. **协调尝试**
    - 对于主路最近的3辆车，依次：
        - 计算主路车和匝道车到达汇入点的时间。
        - 判断是否能让匝道车在主路车前安全汇入（满足安全时距，且速度不低于最低速度）。
        - 若可行，规划两车目标速度，break。
        - 若都不可行，默认匝道车在主路车后汇入。

3. **目标速度下发**
    - 被协调车辆用协调结果，其余车辆按安全时距跟驰，所有车辆速度不低于最低速度。

4. **安全时距调整**
    - 判断车辆是否在汇入区，动态调整安全时距参数。

---

## 你需要关注的主要函数和模块

- `Planner.plan_trajectory`（主逻辑入口）
- `Planner.calculate_safe_distance`（动态调整安全时距）
- `Executor.apply_control`（速度下发与最低速度约束）
- controller.py 的 `update`（车辆排序与协调入口）

---

规则添加：
合流区之前的主干道不要有车辆变道

延迟添加：
将目前的计算结果延迟具体时间推送给车辆（延迟0.1秒，对应推送晚0.1秒）
同时展示当前计算的结果和车辆实际采用的值（研究是列表前推一格）

### 1. delay_model.py
- 所有车辆的通信延迟由初始化参数 `comm_delay` 决定，默认为 0.1 秒，不再动态估计。
- `get_delay(vehicle_id)` 始终返回该固定延迟。

### 2. controller.py
- `RoadsideController` 初始化时，`DelayModel` 只传递一个参数 `communication_delay_mean`，用于设置所有车辆的固定延迟。

### 3. 其他模块
- planner.py、`executor.py`、`history.py`、`vehicle_manager.py` 等模块无需更改，继续通过 `delay_model.get_delay(vehicle_id)` 获取延迟即可。

---

【延迟下发规划速度的协调修改思路】

1. 在 planner.py 中，每次 plan_trajectory 规划后，将所有车辆的 planned_speeds 以 {vehicle_id: speed} 的形式，按仿真步顺序追加保存到一个历史列表（如 self.planned_speeds_history，列表每步为一个字典）。

2. 在 executor.py 的 apply_control 方法中，不再直接使用当前步的 planned_speeds，而是：
   - 对每辆车，先通过 delay_model.get_delay(vehicle_id) 获取该车的延迟（如0.1、0.2、0.3等）。
   - 计算延迟步数 delay_steps = int(delay / dt)，dt为仿真步长（如0.1s）。
   - 从 self.planned_speeds_history 中取出 delay_steps 步之前的 planned_speeds 字典，查找该车辆的目标速度（如果历史不足则取最早的可用值或当前值）。
   - 将该延迟步的目标速度赋值给 vehicle.target_speed，实现“延迟下发”。

3. 保证 planned_speeds_history 的长度与仿真步同步增长，且每步都能回溯到对应历史。

4. 这样每辆车实际采用的目标速度就是“延迟/0.1步前”planner为它规划的速度，能够真实反映通信/执行延迟的影响。

5. 其他模块（如 history 记录、误差分析等）可继续记录当前步的 planned_speeds 和实际速度，便于对比分析。

6. 代码结构建议：
   - planner.py：增加 self.planned_speeds_history，plan_trajectory 每步追加。
   - executor.py：apply_control 读取历史 planned_speeds_history，按延迟步数下发。
   - controller.py：初始化和每步同步 planned_speeds_history。
   - delay_model.py：延迟仍由 get_delay(vehicle_id) 提供。

【这样实现后，车辆的控制延迟可灵活调整，且每辆车可有不同延迟，仿真更真实。】